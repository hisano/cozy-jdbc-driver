package jp.hisano.cozy.jdbc.mysql

import com.github.jasync.sql.db.EMPTY_RESULT_SET
import com.github.jasync.sql.db.QueryResult
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.SQLWarning
import java.sql.Statement
import java.util.concurrent.CompletableFuture
import java.util.concurrent.TimeUnit.SECONDS
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

typealias Mutex = ReentrantLock

internal class CozyStatement(
    val connection: CozyConnection,
    val type: Int,
    val concurrency: Int,
    val holdability: Int
) : Statement {
    private val mutex = Mutex(true)

    private val completableFuture = AtomicReference<CompletableFuture<QueryResult>?>()
    private val queryResult = AtomicReference<QueryResult?>()

    @Volatile
    private var queryTimeoutSeconds = 0

    private val isClosed = AtomicBoolean()

    override fun getQueryTimeout(): Int {
        throwSQLExceptionIfClosed()

        return queryTimeoutSeconds
    }

    private fun throwSQLExceptionIfClosed() {
        if (isClosed()) {
            throw SQLException()
        }
    }

    override fun isClosed(): Boolean = isClosed.get()

    private val isNoQueryTimeout
        get() = queryTimeoutSeconds == 0

    override fun setQueryTimeout(newValue: Int) {
        throwSQLExceptionIfClosed()

        if (newValue < 0) {
            throw SQLException()
        }

        queryTimeoutSeconds = newValue
    }

    override fun cancel() {
        completableFuture.get()?.cancel(true)
    }

    override fun executeQuery(sql: String?): ResultSet? {
        execute(sql)
        return resultSet
    }

    override fun executeUpdate(sql: String?): Int {
        execute(sql)
        return updateCount
    }

    override fun execute(sql: String?): Boolean {
        if (sql == null || sql.length == 0) {
            throw SQLException()
        }

        mutex.withLock {
            val completableFuture = connection.concreteConnection.sendQuery(sql)
            this.completableFuture.set(completableFuture)
            this.queryResult.set(if (isNoQueryTimeout) completableFuture.get() else completableFuture.get(queryTimeoutSeconds.toLong(), SECONDS))
        }

        val queryResult = this.queryResult.get() ?: return false
        return queryResult.rows != EMPTY_RESULT_SET 
    }

    override fun getResultSet(): ResultSet? {
        val queryResult = this.queryResult.get() ?: return null
        if (queryResult.rows == EMPTY_RESULT_SET) {
            return null
        }
        return CozyResultSet(queryResult)
    }

    override fun getUpdateCount(): Int {
        val queryResult = this.queryResult.get() ?: return -1
        if (queryResult.rows != EMPTY_RESULT_SET) {
            return -1
        }
        return queryResult.rowsAffected.toInt()
    }

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        TODO("Not yet implemented")
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        TODO("Not yet implemented")
    }

    override fun close() {
        TODO("Not yet implemented")
    }

    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        TODO("Not yet implemented")
    }

    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        TODO("Not yet implemented")
    }

    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int {
        TODO("Not yet implemented")
    }

    override fun getMaxFieldSize(): Int {
        TODO("Not yet implemented")
    }

    override fun setMaxFieldSize(max: Int) {
        TODO("Not yet implemented")
    }

    override fun getMaxRows(): Int {
        TODO("Not yet implemented")
    }

    override fun setMaxRows(max: Int) {
        TODO("Not yet implemented")
    }

    override fun setEscapeProcessing(enable: Boolean) {
        TODO("Not yet implemented")
    }

    override fun getWarnings(): SQLWarning {
        TODO("Not yet implemented")
    }

    override fun clearWarnings() {
        TODO("Not yet implemented")
    }

    override fun setCursorName(name: String?) {
        TODO("Not yet implemented")
    }

    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        TODO("Not yet implemented")
    }

    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        TODO("Not yet implemented")
    }

    override fun execute(sql: String?, columnNames: Array<out String>?): Boolean {
        TODO("Not yet implemented")
    }

    override fun getMoreResults(): Boolean {
        TODO("Not yet implemented")
    }

    override fun getMoreResults(current: Int): Boolean {
        TODO("Not yet implemented")
    }

    override fun setFetchDirection(direction: Int) {
        TODO("Not yet implemented")
    }

    override fun getFetchDirection(): Int {
        TODO("Not yet implemented")
    }

    override fun setFetchSize(rows: Int) {
        TODO("Not yet implemented")
    }

    override fun getFetchSize(): Int {
        TODO("Not yet implemented")
    }

    override fun getResultSetConcurrency(): Int {
        TODO("Not yet implemented")
    }

    override fun getResultSetType(): Int {
        TODO("Not yet implemented")
    }

    override fun addBatch(sql: String?) {
        TODO("Not yet implemented")
    }

    override fun clearBatch() {
        TODO("Not yet implemented")
    }

    override fun executeBatch(): IntArray {
        TODO("Not yet implemented")
    }

    override fun getConnection(): Connection {
        TODO("Not yet implemented")
    }

    override fun getGeneratedKeys(): ResultSet {
        TODO("Not yet implemented")
    }

    override fun getResultSetHoldability(): Int {
        TODO("Not yet implemented")
    }

    override fun setPoolable(poolable: Boolean) {
        TODO("Not yet implemented")
    }

    override fun isPoolable(): Boolean {
        TODO("Not yet implemented")
    }

    override fun closeOnCompletion() {
        TODO("Not yet implemented")
    }

    override fun isCloseOnCompletion(): Boolean {
        TODO("Not yet implemented")
    }

}